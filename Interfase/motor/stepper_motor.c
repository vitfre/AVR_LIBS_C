/*
 * stepper_motor.c
 *
 * Created: 06.10.2014 16:08:51
 *  Author: Администратор
 */ 

#include "stepper_motor.h"

unsigned char TableSin[33] =  {0,0,13,25,38,51,63,75,87,99,111,122,133,144,154,164,174,183,192,200,207,215,221,227,233,238,242,246,249,251,253,254,255};        //Таблиця СИНУС
//---------------------------------------------------------------------------------------
struct
{
	//---------------------------------------------------------------------------------------
	unsigned TAKT : 2;									// Прозиція півхвилі для значень ШИМ
	unsigned POS : 8;									// Прозиція для значень ШИМ
	//---------------------------------------------------------------------------------------
} SIN;
//---------------------------------------------------------------------------------------
/**************************************************************************
*   Function name : stepper_motor_init
*   Returns :       
*   Parameters :    
*   Purpose :       Настройка управляючих сигналів і запуск шим для мікрошагового режиму
****************************************************************************/
void stepper_motor_init(void)
{
	//---------------------------------------------------------------------------------------
// 	PORT_MOTOR=0b11000000;
// 	DDRX_MOTOR=0b00111111;
	//---------------------------------------------------------------------------------------
	// Timer/Counter 1 initialization
	// Clock source: System Clock
	// Clock value: 16000,000 kHz
	// Mode: Fast PWM top=0x00FF
	// OC1A output: Non-Inv.
	// OC1B output: Non-Inv.
	// OC1C output: Discon.
	// Noise Canceler: Off
	// Input Capture on Falling Edge
	// Timer1 Overflow Interrupt: Off
	// Input Capture Interrupt: Off
	// Compare A Match Interrupt: Off
	// Compare B Match Interrupt: Off
	// Compare C Match Interrupt: Off
// 	TCCR1A=0xA1;
// 	TCCR1B=0x09;
// 	TCNT1H=0x00;
// 	TCNT1L=0x00;
// 	ICR1H=0x00;
// 	ICR1L=0x00;
// 	OCR1AH=0x00;
// 	OCR1AL=0x60;
// 	OCR1BH=0x00;
// 	OCR1BL=0x60;
// 	OCR1CH=0x00;
// 	OCR1CL=0x00;
// 	_delay_ms(50);
	//---------------------------------------------------------------------------------------
	(PORT_MOTOR|=(1<<EN));
	(PORT_MOTOR|=(1<<CTRL));
	(PORT_MOTOR&=~(1<<HALF_FULL));
	(PORT_MOTOR|=(1<<RST));
	(PORT_MOTOR&=~(1<<CLOCK));
	//---------------------------------------------------------------------------------------
};
/**************************************************************************
*   Function name : set_axle_to
*   Returns :       Кількість кроків які зробив двигун
*   Parameters :    заданий кут
*   Purpose :       Ставимо вісь стенда в заданий кут
****************************************************************************/
void set_axle_to(unsigned int angle)
{
	//---------------------------------------------------------------------------------------
	unsigned int DAT_MLX;
	//---------------------------------------------------------------------------------------
	DAT_MLX=get_angle();
	//---------------------------------------------------------------------------------------
	#if ((_MLX_ == 1)&(_TLE_ == 0))			//Датчик Melexis
	//---------------------------------------------------------------------------------------
	if (angle>DAT_MLX)
	{
		//---------------------------------------------------------------------------------------
		do
		{
			//---------------------------------------------------------------------------------------
			if((angle-DAT_MLX)>500)
			{
				rotate(0,25);
				_delay_us(50);
				rotate(0,25);
				_delay_us(50);
			}else
			{
				rotate(0,1);
				_delay_ms(5);
			};
			//---------------------------------------------------------------------------------------
			DAT_MLX=get_angle();
			//---------------------------------------------------------------------------------------
		} while (angle>DAT_MLX);
		//---------------------------------------------------------------------------------------
	}
	else
	{
		//---------------------------------------------------------------------------------------
		do
		{
			//---------------------------------------------------------------------------------------
			if((DAT_MLX-angle)>500)
			{
				rotate(1,25);
				_delay_us(50);
				rotate(1,25);
				_delay_us(50);
			}else
			{
				rotate(1,1);
				_delay_ms(5);
			};
			//---------------------------------------------------------------------------------------
			DAT_MLX=get_angle();
			//---------------------------------------------------------------------------------------
		} while (DAT_MLX>angle);
		//---------------------------------------------------------------------------------------
	};
	//---------------------------------------------------------------------------------------
	#elif ((_MLX_ == 0)&(_TLE_ == 1))		//Датчик Infineon
	//---------------------------------------------------------------------------------------
	if (angle>DAT_MLX)
	{
		//---------------------------------------------------------------------------------------
		do
		{
			//---------------------------------------------------------------------------------------
			DAT_MLX=get_angle();
			//---------------------------------------------------------------------------------------
			if((angle-DAT_MLX)>100)
			{
				rotate(0,10);
				_delay_us(5);
			}else
			{
				rotate(0,1);
				_delay_ms(5);
			};
			//---------------------------------------------------------------------------------------
		} while (angle>DAT_MLX);
		//---------------------------------------------------------------------------------------
	}
	else
	{
		//---------------------------------------------------------------------------------------
		do
		{
			//---------------------------------------------------------------------------------------
			DAT_MLX=get_angle();
			//---------------------------------------------------------------------------------------
			if((DAT_MLX-angle)>100)
			{
				rotate(1,10);
				_delay_us(5);
			}else
			{
				rotate(1,1);
				_delay_ms(5);
			};
			//---------------------------------------------------------------------------------------
		} while (DAT_MLX>angle);
		//---------------------------------------------------------------------------------------
	};
	//---------------------------------------------------------------------------------------
	#endif
	//---------------------------------------------------------------------------------------
};
/**************************************************************************
*   Function name : rotate
*   Returns :       нет
*   Parameters :    Кількість кроків і напряток руху
*   Purpose :       
****************************************************************************/
void rotate(unsigned char temp_vector, unsigned int temp_step)
{
	//---------------------------------------------------------------------------------------
	#if ((_3302_N1_ == 1|_3302_N2_ == 1|_3202_N5_ == 1|_3502_N6_ == 1|_3202_N8_ == 1)&(_3102_N3_ == 0|_3102_N4_ == 0|_3102_N7_ == 0))
		//---------------------------------------------------------------------------------------
		while (temp_step>0)						//Пока есть шаги
		{
			//---------------------------------------------------------------------------------------
			if (temp_vector==1)					//Если направление вперёд
			{
				//---------------------------------------------------------------------------------------
				(PORT_MOTOR|=(1<<direct));			//Переключаем направление
				OCR1AL=TableSin[SIN.POS];		//Загружаем значение синуса
				OCR1BL=TableSin[32-SIN.POS];	//Загружаем значение косинуса
				driver_delay;
				//---------------------------------------------------------------------------------------
			} 
			else
			{
				//---------------------------------------------------------------------------------------
				(PORT_MOTOR&=~(1<<direct));
				OCR1BL=TableSin[SIN.POS];
				OCR1AL=TableSin[32-SIN.POS];
				driver_delay;
				//---------------------------------------------------------------------------------------
			}
			//---------------------------------------------------------------------------------------
			if (SIN.TAKT==1)					//Если первая полуволна синуса
			{
				//---------------------------------------------------------------------------------------
				if (SIN.POS==32)				//Если мы в максимуме
				{
					SIN.TAKT=2;					//Устанавливаем вторую полуволну
					SIN.POS=SIN.POS-sin_step;
					(PORT_MOTOR|=(1<<CLOCK));
				}
				else
				{
					SIN.POS=SIN.POS+sin_step;	//Пока не в максимуме то шагаем нормально
				};
				//---------------------------------------------------------------------------------------
				if(SIN.POS==16)
				{
					(PORT_MOTOR&=~(1<<CLOCK));		//Посреди характеристики переключаем клок
				};
				//---------------------------------------------------------------------------------------
				if(SIN.POS==0)
				{
					(PORT_MOTOR&=~(1<<RST));			//В нулевой точке сбрасываем ресет
					driver_delay;
					(PORT_MOTOR|=(1<<RST));
				};
				//---------------------------------------------------------------------------------------
			}
			else
			{
				//---------------------------------------------------------------------------------------
				if (SIN.POS==0)
				{
					SIN.TAKT=1;
					SIN.POS=SIN.POS+sin_step;
					(PORT_MOTOR|=(1<<CLOCK));
				}
				else
				{
					SIN.POS=SIN.POS-sin_step;
				};
				//---------------------------------------------------------------------------------------
				if(SIN.POS==16)
				{
					(PORT_MOTOR&=~(1<<CLOCK));		//Посреди характеристики переключаем клок
				};
				//---------------------------------------------------------------------------------------
			};
			temp_step--;
			//---------------------------------------------------------------------------------------
		};	//
	#elif ((_3302_N1_ == 0|_3302_N2_ == 0|_3202_N5_ == 0|_3502_N6_ == 0|_3202_N8_ == 0)&(_3102_N3_ == 1|_3102_N4_ == 1|_3102_N7_ == 1))
		while (temp_step>0)						//Пока есть шаги
		{
			//---------------------------------------------------------------------------------------
			if (temp_vector==0)					//Если направление вперёд
			{
				//---------------------------------------------------------------------------------------
				(PORT_MOTOR|=(1<<direct));			//Переключаем направление
				OCR1AL=TableSin[SIN.POS];		//Загружаем значение синуса
				OCR1BL=TableSin[32-SIN.POS];	//Загружаем значение косинуса
				driver_delay;
				//---------------------------------------------------------------------------------------
			}
			else
			{
				//---------------------------------------------------------------------------------------
				(PORT_MOTOR&=~(1<<direct));
				OCR1BL=TableSin[SIN.POS];
				OCR1AL=TableSin[32-SIN.POS];
				driver_delay;
				//---------------------------------------------------------------------------------------
			}
			//---------------------------------------------------------------------------------------
			if (SIN.TAKT==1)
			{
				//---------------------------------------------------------------------------------------
				if (SIN.POS==32)				//Если первая полуволна синуса
				{								//Если мы в максимуме
					SIN.TAKT=2;					//Устанавливаем вторую полуволну
					SIN.POS=SIN.POS-sin_step;
					(PORT_MOTOR|=(1<<CLOCK));
				}
				else
				{
					SIN.POS=SIN.POS+sin_step;	//Пока не в максимуме то шагаем нормально
				};
				//---------------------------------------------------------------------------------------
				if(SIN.POS==16)
				{
					(PORT_MOTOR&=~(1<<CLOCK));		//Посреди характеристики переключаем клок
				};
				//---------------------------------------------------------------------------------------
				if(SIN.POS==0)
				{
					(PORT_MOTOR&=~(1<<RST));			//В нулевой точке сбрасываем ресет
					driver_delay;
					(PORT_MOTOR|=(1<<RST));
				};
				//---------------------------------------------------------------------------------------
			}
			else
			{
				//---------------------------------------------------------------------------------------
				if (SIN.POS==0)
				{
					SIN.TAKT=1;
					SIN.POS=SIN.POS+sin_step;
					(PORT_MOTOR|=(1<<CLOCK));
				}
				else
				{
					SIN.POS=SIN.POS-sin_step;
				};
				//---------------------------------------------------------------------------------------
				if(SIN.POS==16)
				{
					(PORT_MOTOR&=~(1<<CLOCK));		//Посреди характеристики переключаем клок
				};
				//---------------------------------------------------------------------------------------
			};
			temp_step--;
		};
	#endif
};
/**************************************************************************
*   Function name : preset_drivers
*   Returns :       нет
*   Parameters :    нет
*   Purpose :       Конфігуримо драйвер крокового двигуна і стаємо в нуль стенда
****************************************************************************/
void preset_drivers(void)
{
	//---------------------------------------------------------------------------------------
	stepper_motor_init();
	//---------------------------------------------------------------------------------------
	get_angle();
	_delay_ms(100);
	set_axle_to(ANGLE_MIN);
	//---------------------------------------------------------------------------------------
};
//***************************************************************************************
//***************************************************************************************
//***************************************************************************************