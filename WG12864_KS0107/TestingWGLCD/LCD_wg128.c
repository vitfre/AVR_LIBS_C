#include<LCD_wg128.h>
#include <symtable.h>


// Пишем команду в выбранный контроллер
void LCD_WR_COM(u08 cmd,u08 CSC)
{					// Поднятие сигналов:
LCD_SET_CMD;		// Команда
LCD_SET_W;			// Запись

ON_CS(CSC);			// Выбор чипа


LCD_DATA_INS(cmd);	// Команду на шину данных

NOPS;				// Подождем
LCD_PUL_E;			// Дрыгнем стробом
NOPS;				// Подождем

LCD_OFF_CS1;		// Выключим 
LCD_OFF_CS2;		// выбор кристалла
}

// Пишем данные в контроллер
void LCD_WR_DATA(u08 cmd, u08 CSC)
{					// Поднятие сигналов
LCD_SET_DAT;		// Данные
LCD_SET_W;			// Запись

ON_CS(CSC);			// Выбор чипа

LCD_DATA_INS(cmd);	// Данные на шину данных

NOPS;				// Подождем 
LCD_PUL_E;			// Дрыгнем стробом
NOPS;				// Подождем


LCD_OFF_CS1;		// Выключим выбор
LCD_OFF_CS2;		// Чипа.
}


// Заливка экрана 
void LCD_FILL(u08 byte)
{
	for(u08 i=0; i<8; i++)					//Перебирая страницы X от 0 до 7
	{
		LCD_WR_COM(0xB8+i,(1<<CS1|1<<CS2));	//Льем параллельно в оба чипа. 0xB8 задает тип операции (адрес страницы)

		for(u08 j=0; j<64; j++)				// Задаем адрес Y от 0 до 64
			{
			LCD_WR_COM(0x40+j,(1<<CS1|1<<CS2));		// Записываем адрес У в контроллер.
			LCD_WR_DATA(byte,(1<<CS1|1<<CS2));		// Записываем в байт с адресом ХУ  нужное значение
			}
	}
}


// Чтение данных из байта, адрес которого уже должен быть установлен. Надо только выбрать
// контроллер.
u08 LCD_RD_DATA(u08 CSC)
{
u08 outv;

						// Выставляем линии управления
LCD_SET_DAT;			// Данные
LCD_SET_R;				// Чтение

ON_CS(CSC);				// Выбираем чип (только один!) 

NOPS;					// Ждем
LCD_PUL_E;				// Дрыг стробом - пустое чтение, активация защелки
NOPS;					// Ждем
		
LCD_UP_E;				// Строб вверх
NOPS;					// Ждем
outv = LCD_DATA_PIN;	// Контроллер выдал данные на шину. Читаем их 
LCD_DN_E;				// Строб вниз

LCD_OFF_CS1;			// Все свободны!
LCD_OFF_CS2;

return outv;			// Возвращаем считанное 
}


// Процедура установки пикселя. Т.к. пиксель часть байта, то надо сначала вычислить
// Контроллер, потом страницу и нужный байт. Считать этот байт. Изменить в нем только один,
// нужный, бит и вернуть его на место.
// На входе координаты и режим обработки пикселя (вкл, выкл, переключение)
void PIXEL(u08 x,u08 y,u08 mode)
{
u08 CSS, row, col, byte;
u08 res,read;

if(y>63)					// Проверяем в каком контроллере искомый пиксель
	{
	CSS = 1<<CS2;			// Если У больше 63 значит во втором. Выставляем 2й 
	col = y-64;				// И отнимаем смещение, чтобы не мешалось. 
	}
else
	{
	CSS = 1<<CS1;			// Иначе контроллер у нас первый. 
	col = y;				// А смещения нет. 
	}

row = x>>3;					// Делим Х на 8, чтобы получить номер страницы. 
byte = 1<<x%8;				// А остаток от деления даст нам искомый бит, который мы задвигаем
							// и получаем нужную нам битмаску для модификации байта. 

SET_ADDR(row,col,CSS);		// выставляем адрес
read = LCD_RD_DATA(CSS);	// Читаем данные (адрес при этом ++ аппаратно). 

switch(mode)				// В зависимости от режима
	{
	case 0:							// Clear
			{
			res = read & ~byte;		// Накладываем сбрасывающую (NOT) маску
			break;
			}	
	case 1:		// Invert
			{
			res = read ^ byte;		// Накладываем инвертирующую (ХОR) маску 
			break;
			}
	default:		// Set
			{
			res = read | byte;		// Накладываем устанавливающую (OR) маску
			break;
			}
	}

SET_ADDR(row,col,CSS);		// Повторно выставляем адрес. Т.к. чтение его исказило.
LCD_WR_DATA(res,CSS);		// Вгоняем туда результат нашей модификации. 
}


// Запись сразу блока. Удобно для вывода строк или картинок, постранично. 
// На входе страница Х и колонка У. А также длина блока и адрес откуда брать данные.
u08 BLOCK(u08 x,u08 y, u08 len, u16 addr)
{
u08 CSS,i,col;

if(y>63)					// Сначала вычисляем нужные нам сегмент (чип)
	{
	CSS = 1<<CS2;
	col = y-64;
	}
else
	{
	CSS = 1<<CS1;
	col = y;
	}

SET_ADDR(x,col,CSS);					// Ставим адрес

// А дальше в цикле гоним байты. Не забывая увеличивать адрес, чтобы была выборка из
// памяти. Счетчик, чтобы не сбиться со счета. И номер колонки, чтобы не вылезти за границы
// И вообще понимать где мы находимся. 
for(i=0;i!=len;i++,addr++,col++)
	{
	if(64==col)						// Попутно проверяем за границы выхода из сегмента
		{
		if(CSS == (1<<CS2))			// Если случилось, и у нас второй сегмент, т.е. конец
			{						// страницы (уже второй в этой строке)
			return 128;				// выходим с кодом ошибки (код больше разрешения экрана)
			}

		col=0;						// Иначе же обнуляем счетчик колонок. И переключаем банку
		CSS = 1<<CS2;				// Выбрав второй сегмент экрана
		SET_ADDR(x,col,CSS);		// И выставив новый текущий адрес
		}

	LCD_WR_DATA(pgm_read_byte(addr),CSS);	// Пишем туда данные прям из флеша (таблица символов). 
	}
return y+len;						// Возвращаем координату увеличиную на размер блока.
}


// Процедура вывода строки. На входе строка, и координаты. Х в страницах, а У в точках.
void LCD_putc(u08 x,u08 y,u08 *string)
{
u08 sym;

while (*string!='\0')	// Пока первый байт строки не 0 (конец ASCIIZ строки)
	{
		if(127<y)		// Проверяем за границу выхода за экран. Если вылезаем
			{			// Вот тут, кстати, можно поиграть с числом, чтобы не рубило последний символ.
			y=0;			// То обнуляем координату точки. 
			x++;			// Выставляем следующую строку
			if(x>7) break;	// Если экран и вниз кончился - выход. 
			}

	sym = *string-0x20;		// Вычисляем из ASCII кода смещение в таблице символов. 
							// Для русского языка и цифр надо условия добавить. Т.к. 
							// таблица там не полная, не 255 байт.

	y = BLOCK(x,y+1,5,(u16)symboltable+sym*5);	// Закатываем этот блок. 
	string++;									// Не забывая увеличивать указатель,
	}
}


// Инициализация дисплея.
void LCD_INIT(void)
{
LCD_PORT_INIT;			// Выставляем правильным образом порт
LCD_RST;				// Даем дисплею сброс (сбрасываются адреса, но не видеопамять)
_delay_ms(10);						// Ждем на всякий случай (попробовать убрать нахер)
LCD_WR_COM(0x3F,(1<<CS1|1<<CS2));	// Включаем дисплей
LCD_WR_COM(0x40,(1<<CS1|1<<CS2));	// Устанавливаем нулевой адрес
LCD_WR_COM(0xB8,(1<<CS1|1<<CS2));	
LCD_WR_COM(0xC0,(1<<CS1|1<<CS2));
LCD_FILL(0);						// Заливаем нулем. Очистка экрана. 
}
